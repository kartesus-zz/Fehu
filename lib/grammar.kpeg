%% name = Fehu::Parser

%% {
  attr_accessor :ast

  def initialize(*args)
    super
    @ast = [:module, []]
  end

  def add(node)
    @ast = [:module, @ast.last.push(node)]
  end
}

eof   = !.
space = " " | "\t"
nl    = "\n" | ";"
sp    = space+
-     = space*
brsp  = (space | nl)*
eoe   = - (comment | nl) brsp

literal = tagged_value | tag | float | int | string | atom

pipe    = pipe:a brsp ">" - call:b { [:call, b, a] } 
        | call:a brsp ">" - call:b { [:call, b, a] }

bind    = atom:a - "=" - call:c { [:bind, a, c] }

expr    = pipe | call | lambda
top     = bind:b ~add(b) | expr:e ~add(e)

module = (comment | top eoe)+

root = eoe* module brsp eof 

# COMMENT ----------------------------------------------------
comment = "--" (!nl .)* nl

# ATOM -------------------------------------------------------
name = < /[a-z][a-z\-]*/ > { text }
atom = name:n { [:atom, n.to_sym] }

# NUMBERS ----------------------------------------------------
number = < ( "0" | /[1-9][0-9]*/ ) > { text }
int    = number:n { [:int, n.to_i] }
float  = number:w "." number:f { [:float, "#{w}.#{f}".to_f] }

# TAGS -------------------------------------------------------
tag           = ":" name:n { [:tag, n] }
tagged_value  = tag:t (space call)+:l { t.concat(l) }
              | "(" - tagged_value:t - ")" { t }

# STRING -----------------------------------------------------
num_escapes     = < /[0-7]{1,3}/ > { [text.to_i(8)].pack("U") } | "x" < /[a-f\d]{2}/i > { [text.to_i(16)].pack("U") }
string_escapes  = "n" { "\n" } | "s" { " " } | "r" { "\r" } | "t" { "\t" } | "v" { "\v" } | "f" { "\f" } | "b" { "\b" } | "a" { "\a" } | "e" { "\e" } | "\\" { "\\" } | "\"" { "\"" } | num_escapes | < . > { text }
string_seq      = < /[^\\"]+/ > { text }
string_body     = ("\\" string_escapes:s | string_seq:s)*:ary { Array(ary) }
string          = "\"" string_body:s "\"" { [:string, s.join] }

# FUNCTION ---------------------------------------------------
parameters = expr:h (brsp expr)*:t { [h] + t }
call       = "[" (atom | lambda):a brsp parameters:b - "]" { [:call, a, b] } | literal

arguments = literal:h (sp literal)*:t { [h] + t }
lambda    = "[" sp arguments:a sp "->" sp expr:b sp "]" { [:lambda, a, b] }
