%% name = Fehu::Parser

%% {
  attr_accessor :ast

  def initialize(*args)
    super
    @ast = [:module, :main, []]
  end

  def add(node)
    @ast = [:module, :main, @ast.last.push(node)]
  end
}

%% ast-location = ::Fehu::AST
%% int          = ast Int(value)
%% float        = ast Float(value)
%% strlit       = ast String(value)
%% atom         = ast Atom(name)
%% tag          = ast Tag(name, values)
%% call         = ast Call(callable, arguments)
%% lcase        = ast Case(params, expr)
%% lambda       = ast Lambda(cases)
%% bind         = ast Bind(atom, expr)
%% blank        = ast Blank()

eof   = !.
space = " " | "\t" | ","
nl    = "\n" 
sp    = space+
-     = space*
brsp  = (space | nl)*
eoe   = - (comment | ";" | nl) brsp

literal = tag | float | int | string | atom

pipe    = pipe:a brsp   ">" - call:b ~call(b, [a])
        | (call | lambda):a brsp   ">" - (call | lambda):b ~call(b, [a])
        | "(" - pipe - ")"

bind    = atom:a - "=" - expr:b ~bind(a, b)

expr    = pipe | call | lambda
top     = bind:b ~add(b) | expr:e ~add(e)

module = (comment | top eoe)+

root = eoe* module brsp eof 

# COMMENT ----------------------------------------------------
comment = "--" (!nl .)* nl

# ATOM -------------------------------------------------------
name = < /[a-z][a-z\-_]*/ > { text }
atom = name:n ~atom(n)

# NUMBERS ----------------------------------------------------
number = < ( "0" | /[1-9][0-9]*/ ) > { text }
int    = number:n ~int(n)
float  = number:w "." number:f ~float("#{w}.#{f}".to_f)

# TAGS -------------------------------------------------------
tag           = ":" name:n (space call)+:l ~tag(n, l)
              | ":" name:n ~tag(n, [])
              | "(" - tag:t - ")" { t }

# STRING -----------------------------------------------------
num_escapes     = < /[0-7]{1,3}/ > { [text.to_i(8)].pack("U") } | "x" < /[a-f\d]{2}/i > { [text.to_i(16)].pack("U") }
string_escapes  = "n" { "\n" } | "s" { " " } | "r" { "\r" } | "t" { "\t" } | "v" { "\v" } | "f" { "\f" } | "b" { "\b" } | "a" { "\a" } | "e" { "\e" } | "\\" { "\\" } | "\"" { "\"" } | num_escapes | < . > { text }
string_seq      = < /[^\\"\n]+/ > { text }
string_body     = ("\\" string_escapes:s | string_seq:s)*:ary { Array(ary) }
string          = "\"" string_body:s "\"" ~strlit(s.join)

# FUNCTION ---------------------------------------------------
parameters = (expr | blank):h (brsp (expr | blank))*:t { [h] + t }
blank      = "_" ~blank()
call       = "[" (atom | lambda):a brsp parameters:b - "]" ~call(a, b) 
           | atom:a "!" ~call(a, [])
           | literal

arguments = literal:h (sp literal)*:t { [h] + t } | < "!" > { [] }
case      = arguments:a sp "->" sp expr:b ~lcase(a, b)
lambda    = "[" sp case:a (brsp "|" brsp case)*:b sp "]" ~lambda([a].concat(b))
